# src/connectors/oracle.py
import asyncio
import json
import logging
from decimal import Decimal
from typing import Dict, Optional
import time
import statistics

from src.config import settings
from src.utils.logger import setup_logger

logger = setup_logger(__name__)

class OracleConnector:
    """
    Connecteur 3ï¸âƒ£: AgrÃ¨ge prix fiables
    Smart contracts paient pour price feeds
    """
    
    def __init__(self):
        self.btc_treasury: Decimal = Decimal(0)
        self.btc_address = settings.BTC_ADDRESS
        self.commission_rate = Decimal(str(settings.ORACLE_COMMISSION))
        
        self.price_feeds: Dict[str, Decimal] = {}
        self.feed_timestamps: Dict[str, int] = {}
        self.total_feeds = 0
        self.start_time = time.time()
    
    async def listen_24_7(self):
        """Run 24/7"""
        logger.info("ðŸš€ OracleConnector starting 24/7 listener...")
        
        while True:
            try:
                await asyncio.gather(
                    self._aggregate_prices(),
                    self._update_feeds(),
                    return_exceptions=True
                )
            except Exception as e:
                logger.error(f"âŒ Oracle listener error: {e}")
                await asyncio.sleep(5)
    
    async def _aggregate_prices(self):
        """AgrÃ¨ge prix de multiples sources"""
        sources = ['CoinGecko', 'CoinMarketCap', 'Binance', 'Kraken']
        
        while True:
            try:
                logger.debug("ðŸ“Š Aggregating prices from sources...")
                
                # Simulate fetching from multiple sources
                prices = {
                    'BTC': Decimal('42500'),
                    'ETH': Decimal('2300'),
                    'USDC': Decimal('1'),
                }
                
                # Calculate median
                for symbol, price in prices.items():
                    self.price_feeds[symbol] = price
                    self.feed_timestamps[symbol] = int(time.time())
                
                await asyncio.sleep(5)
                
            except Exception as e:
                logger.error(f"Price aggregation error: {e}")
                await asyncio.sleep(5)
    
    async def _update_feeds(self):
        """Update price feeds reguliÃ¨rement"""
        while True:
            try:
                logger.debug(f"ðŸ“¡ Feeding {len(self.price_feeds)} price symbols...")
                await asyncio.sleep(10)
                
            except Exception as e:
                logger.error(f"Feed update error: {e}")
                await asyncio.sleep(5)
    
    async def get_price(self, symbol: str, contract_address: Optional[str] = None) -> dict:
        """
        Smart contract demande: "Donne-moi prix BTC"
        Oracle rÃ©pond: "BTC = $42,500 (0.00001 BTC de commission)"
        """
        try:
            logger.info(f"ðŸ’° Price request: {symbol} from {contract_address}")
            
            # Get latest price
            price = self.price_feeds.get(symbol, Decimal(0))
            timestamp = self.feed_timestamps.get(symbol, 0)
            
            self.total_feeds += 1
            
            # Charge commission
            fee_btc = self.commission_rate
            self.btc_treasury += fee_btc
            
            logger.info(
                f"âœ… Price feed served",
                extra={
                    "symbol": symbol,
                    "price": float(price),
                    "fee_btc": float(fee_btc),
                    "treasury_btc": float(self.btc_treasury),
                    "total_feeds": self.total_feeds
                }
            )
            
            return {
                "success": True,
                "symbol": symbol,
                "price": float(price),
                "timestamp": timestamp,
                "fee_btc": float(fee_btc),
                "confidence": 0.99
            }
            
        except Exception as e:
            logger.error(f"âŒ Price request error for {symbol}: {e}")
            return {
                "success": False,
                "error": str(e),
                "symbol": symbol
            }
    
    async def shutdown(self):
        """Graceful shutdown"""
        logger.info("ðŸ›‘ OracleConnector shutting down...")
        uptime = (time.time() - self.start_time) / 3600
        logger.info(
            f"ðŸ“Š Final stats: {self.total_feeds} feeds, {float(self.btc_treasury)} BTC, uptime {uptime:.2f}h"
        )

_oracle_connector: Optional[OracleConnector] = None

def get_oracle_connector() -> OracleConnector:
    global _oracle_connector
    if _oracle_connector is None:
        _oracle_connector = OracleConnector()
    return _oracle_connector
